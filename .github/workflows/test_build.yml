name: Create public test build

on:
  workflow_dispatch:
    inputs:
      identifier:
        description: 'Unique identifier (branch/PR name or number)'
        required: true
        type: string
      expire_hours:
        description: 'Number of hours until the test build expires'
        required: true
        default: '24'
        type: number

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  TEST_TAG: manual-test-${{ github.run_id }}

jobs:
  build-test-image:
    name: Build test image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Generate sanitized identifier
        run: |
          # Convert the identifier to a valid hostname segment
          SANITIZED_ID=$(echo "${{ github.event.inputs.identifier }}" | tr -cd 'a-zA-Z0-9-' | tr '[:upper:]' '[:lower:]')
          echo "SANITIZED_ID=${SANITIZED_ID}" >> $GITHUB_ENV
        
      - name: Log in to the Container registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.TEST_TAG }}
          build-args: |
            APP_VERSION=test-build-${{ env.SANITIZED_ID }}

  deploy-public-test:
    name: Deploy Public Test Environment
    needs: build-test-image
    runs-on: [self-hosted, Linux, testing]
    environment:
      name: Public Test - ${{ github.event.inputs.identifier }}
      url: https://${{ github.event.inputs.identifier }}.test-api.profcomff.com/docs
    steps:
      - name: Generate sanitized identifier
        run: |
          # Convert the identifier to a valid hostname segment
          SANITIZED_ID=$(echo "${{ github.event.inputs.identifier }}" | tr -cd 'a-zA-Z0-9-' | tr '[:upper:]' '[:lower:]')
          echo "SANITIZED_ID=${SANITIZED_ID}" >> $GITHUB_ENV
          
          # Generate a short hash for the run ID
          SHORT_HASH=$(echo "${{ github.run_id }}" | sha256sum | cut -c1-8)
          echo "SHORT_HASH=${SHORT_HASH}" >> $GITHUB_ENV
          
          # Set derived environment variables
          echo "CONTAINER_NAME=com_profcomff_api_rental_test_${SANITIZED_ID}" >> $GITHUB_ENV
          echo "TEST_PORT=$((8080 + (${{ github.run_id }} % 1000)))" >> $GITHUB_ENV
          echo "DOMAIN=${SANITIZED_ID}.test-api.profcomff.com" >> $GITHUB_ENV
          
      - name: Pull test image
        run: docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.TEST_TAG }}
        
      - name: Create test database
        run: |
          # Generate unique database name
          DB_NAME="rental_test_${SANITIZED_ID}_${SHORT_HASH}"
          echo "DB_NAME=$DB_NAME" >> $GITHUB_ENV
          
          # Create database
          docker run --rm \
            --network=web \
            postgres:15 \
            psql -h postgres -U ${{ secrets.DB_USER }} -c "CREATE DATABASE $DB_NAME;"
          
          # Create connection string
          echo "DB_DSN=postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@postgres:5432/$DB_NAME" >> $GITHUB_ENV
          
      - name: Set up database schema
        run: |
          docker run \
            --rm \
            --network=web \
            --env DB_DSN='${{ env.DB_DSN }}' \
            --name ${{ env.CONTAINER_NAME }}_migration \
            --workdir="/" \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.TEST_TAG }} \
            alembic upgrade head
            
      - name: Start test application
        run: |
          docker stop ${{ env.CONTAINER_NAME }} || true && docker rm ${{ env.CONTAINER_NAME }} || true
          docker run \
            --detach \
            --restart on-failure:3 \
            --network=web \
            --publish ${{ env.TEST_PORT }}:8000 \
            --env DB_DSN='${{ env.DB_DSN }}' \
            --env ROOT_PATH='/' \
            --env DOCS_URL='/docs' \
            --env OPENAPI_URL='/openapi.json' \
            --env REDOC_URL='/redoc' \
            --env AUTH_URL='https://api.test.profcomff.com/auth' \
            --env SWAGGER_UI_OAUTH2_REDIRECT_URL='/docs/oauth2-redirect' \
            --env ENVIRONMENT='test' \
            --env DEBUG='true' \
            --name ${{ env.CONTAINER_NAME }} \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.TEST_TAG }}
            
      - name: Configure Nginx for public access
        run: |
          cat > /etc/nginx/conf.d/${{ env.DOMAIN }}.conf << EOF
          server {
            listen 80;
            server_name ${{ env.DOMAIN }};
            
            location / {
              proxy_pass http://localhost:${{ env.TEST_PORT }};
              proxy_set_header Host \$host;
              proxy_set_header X-Real-IP \$remote_addr;
              proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto \$scheme;
            }
          }
          EOF
          
          # Reload Nginx
          nginx -t && systemctl reload nginx
          
      - name: Set up SSL with Certbot
        run: |
          certbot --nginx -d ${{ env.DOMAIN }} --non-interactive --agree-tos -m ${{ secrets.ADMIN_EMAIL }}

      - name: Create cleanup script
        run: |
          cat > /tmp/cleanup_${{ env.SANITIZED_ID }}_${{ env.SHORT_HASH }}.sh << 'EOF'
          #!/bin/bash
          set -e
          
          # Variables from workflow
          CONTAINER_NAME="${CONTAINER_NAME}"
          DB_NAME="${DB_NAME}"
          DOMAIN="${DOMAIN}"
          DB_USER="${DB_USER}"
          
          echo "Stopping and removing container..."
          docker stop ${CONTAINER_NAME} || true
          docker rm ${CONTAINER_NAME} || true
          
          echo "Dropping database..."
          docker run --rm --network=web postgres:15 \
            psql -h postgres -U ${DB_USER} -c "DROP DATABASE IF EXISTS ${DB_NAME};"
          
          echo "Removing nginx configuration..."
          rm -f /etc/nginx/conf.d/${DOMAIN}.conf
          nginx -t && systemctl reload nginx
          
          echo "Cleanup completed successfully"
          EOF
          
          chmod +x /tmp/cleanup_${{ env.SANITIZED_ID }}_${{ env.SHORT_HASH }}.sh
          
      - name: Schedule cleanup
        run: |
          # Schedule cleanup after specified hours
          echo "CONTAINER_NAME=${{ env.CONTAINER_NAME }} DB_NAME=${{ env.DB_NAME }} DOMAIN=${{ env.DOMAIN }} DB_USER=${{ secrets.DB_USER }} /tmp/cleanup_${{ env.SANITIZED_ID }}_${{ env.SHORT_HASH }}.sh" | at now + ${{ github.event.inputs.expire_hours }} hours
          
      - name: Show access information
        run: |
          echo "::notice::Test API is available at https://${{ env.DOMAIN }}"
          echo "::notice::Swagger UI is available at https://${{ env.DOMAIN }}/docs"
          echo "::notice::OpenAPI JSON is available at https://${{ env.DOMAIN }}/openapi.json"
          echo "::notice::ReDoc is available at https://${{ env.DOMAIN }}/redoc"
          echo "::notice::This test environment will be automatically removed after ${{ github.event.inputs.expire_hours }} hours"
